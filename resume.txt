GIT/SVN/diff-patch :patch.print(sources) apress.//
1.***********************
But de la biblio: machines a etats::
>chaque fonction prend un void* depuis un lancement initial renvoie un int qui indique un saut vers une autre fonction <=> machine a etats.
..////
->MIT liscence + auteur: allali.(fichier LISCENCE PAS Readme.md qui decrit ce que fait la bibliotheque avec les conventions + la documentation(comment l'utiliser , ainsi de suite..))
systeme de gestion de sources: decentralise git.
NON copyright pour une liscence (+<-### attention ! ;;;)
------------------------
mkdir a l'avant puis git clone (deja fait..(<<)).
systeme de compilation : cmake.(systeme permettant de faire l'out source building (donc .compilation UNIQUEMENT))
systeme de documentation: doxygen doc/Doxyfile.in non lance comme cmake jusqu'a present c'est normal pas comme notr propre ++release()().
----------------------------------------
cmake .. && make && demos/demo_menu+''<<<|>><<||||demo_basic.
make install cree probleme sans indication de ou on doit installer (a l'exterieur peut etre /usr c'est mieux).
=>rm -rf * build && cmake -DCMAKE_INSTALL_PREFIX:PATH=$HOME/usr
=>on relance: cmake avec l'option puis make puis make install.
=>=>repercusions immediates sur ~/Bureau/usr_install_2 (tests+).
=>make donc aussi depuis build puis firefox doc/html/index.html.
tout est bien(autre cote aussi~+).
RQ:
ON PEUT faire cmake avec cette option direct ca va faire le make avant + l'installation de include lib dans $HOME(~)/usr apres make install mais make doc nn.
sudo make install est l'unique choix pour faire un run sans erreur car ca copie les fichiers dans /usr/local/include(.h) && /usr/local/lib(les biblios dynamiques dela libc utilisees instinctivement par GCC.)
------------------------------------------------------------------

2:*********************(diff/patch)
changer la documentation state_start par exemple=>tjrs (90%)voir ateliers_projets fichiers dispos d'origines (initial commit) .h
=>cd depuis cp -r statelib statelib_new puis cd bon folder puis cd src puis cat state.h pour voir.
rq:(install)******************
TARGETS DESTINITATION dans install() le fichier cmake.txt renvoie le repertoir par defaut a choisir eventuellement cest pour cela qu'on ajoute l'option fondamentale a ne pas oublier:
-CMAKE_INSTALL_PREFIX:PATH=$HOME/usr pour une installation dans ~/usr. (ou bien sudo make install comme ca l'ajout avec <> ne posera pas de problemes..)
revenir a l'exo4:
tout a ete fait, les exemples ont ete bien traites pour choisir la tres bonne proche(bonne!!) implementation de game1__2 && searching_number__game => demo/demo3 && demo/demo3_v2 via le CMakeLists dans le folder (**)demos(build :../ terminal.///)::
 +aadd_executable(.. ..)//classique
 ++target_link_libraries(executable$''```` ${STATE_LIBRARIES}).
et depuis statelib_new on fait un cd build3 && cmake -DCMAKE_INSTALL_PREFIX:PATH=$HOME .. && make && make doc 
=>on visualise le :>(sortie) $(firefox ''./doc/html/index.html'') qst1/2
==>on execute les programmes (**)=>TOUT MARCHE.
FIN EXO4: modifications.
_______________________
__________________________________EXO5/6: application/observations diverses(../$($$)) de diff-patch (FRAMEWORK<-->principe des egstionnaires de sources=>$$*($$$<<<<<|./&..////²²²²²²))
EXO5: DIFF
commandes a reprendre(rappels seulement) avec options si necessaire:
diff -r(git diff au debut sur le repository personnel de github)
diff -y(en mode parallele + details sous que faire documentation state.h par exemple
+les repertoirs non pas de recherche recursif si ajout complet contrairement a src=>break
=>documentation sur state.h..) ne sert pas a grand chose.<=>~-++diff -r.
diff
diff -rupN
diff -r -x .git build(exemple) original new
diff -ru -x .git -x ...
jusqu'a diff -rupN -x .git -x build ...
RQ: les options r/ru/rup ne donnent pas grand choses mais permettent de mieux visualiser les trucs=>l'ajout de N est fondamental.(tenant compte des -x ?? pour que l'ensemble #??# ne soit pas lui aussi analyse par rapport a l'ajout des lignes du second image importe cp -R muis mv puis modifiees)
(details: diff -r -x .git -x ('file') original new) VOIR PLUS BAS.
EXO6: patch(de meme => procedure de l'exo precedent(EXO5))
(probleme=>generationde patch anticipee triviale!(*))
diff -rupN -x .git ignore en comparaison resursive la presence ou pas des fichiers .git.(la comparaison par exemple pour -x build va pas comparer statelib/build et statelib_new/build cest pour cela il est recommande de faire les build a l'EXTERIEUR mais le readme initial imposait une construction conforme au CMakeLists se retrouvant dans demos par exemple pour link_directories donc on se confie a la documentation car meme si on modifie tout on peut pas COMMITER)
=>on genere au lieu de patch_number le patch2_real.
**********************-------------------------------------------------------------
EXO7:
Resume: pour faire un patch on utilise uniquement les options diff -rupN original new > patch_`${second_patch__name}`.
Le patch etant pres: patch_real2.
=>comparaison tenu en compte de l'ajout des commentaires dans les fichiers sources headers(contrats) tout au debut + l'ajout d'autres fichiers tests (2) + l'updating du Makefile.
fin_resume__etapes PRECEDENTES.
A CONCLURE POUR LA __suite__::: diff -rupN -x .git -x build_?? ()..()'-x-><-number' original new > rslt_patch.print_ ou rslt_patch tout simple.
->REVENONS A LEXO7:
MAIS<<: parfois, il faut bien examiner les cas car l'application ulterieure du patch CE QUI EST L'objet de cet exo pose des problemes de post-configuration().
=>DETAILS.
Rq:
LE prof a precise qu'il a pu transporter la machine a etats sans toucher aux fonctionnalitées cad. les fonctions proposees ce qui est vraiment l'OBJECTIF d'une machine a etats.
=>=>=>REPRENONS PLUS EN **PROFONDEUR** l'exo7:
creation d'une copie de statelib en statelib2
PUIS: diff -rupN (u:context&p:functions&r:recursivite en recherche & comparaison des ajouts && N END for generating the main line codes for the patch_number) statelib2 statelib_new2 (copie de ce dernier aussi apres AVOIR SUPPRIMER TOUT LES REPERTOIRS BUILD) avec les flags::²
                       -x .git -x build(comme rm -r''f'') 
                          >patch_number.
PUIS: cd statelib2_patched copie de statelib2 sans le build commeon a dit avant puis:
patch < ../patch_games avec l'option !!!!!!!!!!!!!!-p1-----------------(voir commit comment's).
!!!!!!!!!!!!!!!!!!!!!!!!!!
application et repertoriation des modifications puis diff -r => difference au niveau des .git seulement cat -x .git les a sautées.(pas besoin car pas acces(bloqué pas de repository contenant celui-ci) pour y acceder donc le .git on s'en fiche)
&& les cmakelists.txt.??? sont totalement exclus car: tout simplement::
-p1 avec ++++++++++++++++++++++++build sans ne fait rien meme les executables de 'sortie' de doc sont sautées(voir td precedent).
FIN___EXO7.
**********
*******************
*******************************************
EXO8:(a present)
=>debut_exo__8;;;
"" diff -rupN -x .git statelib2_patched/ statelib2_patched/
ne donne rien apres cela (rq a l'avant). "" &!:::
diff -r statelib_new2 statelib2_patched/
Les fichiers binaires statelib_new2/.git/index et statelib2_patched/.git/index sont différents
&(dernier)en mode nn recursif: 
diff statelib_new2 statelib2_patched/
Les sous-répertoires statelib_new2/demos et statelib2_patched/demos sont identiques
Les sous-répertoires statelib_new2/doc et statelib2_patched/doc sont identiques
Les sous-répertoires statelib_new2/.git et statelib2_patched/.git sont identiques
Les sous-répertoires statelib_new2/src et statelib2_patched/src sont identiques
>pas de comparaison de fond.(.git est lui aussi copie bien evidemment: commande cp -r)
sans OUBLIER:
diff -r statelib2 statelib2_patched/
qui visualise les modifications <=> cat ./patch_number presque(100%).////
>>
DEBUT:
>>>>
rq:
git diff -r| par rapport a la branche actuelle seulement!!!
cp ~/T(tab)<é.. ./ puis gunzip patch.print_.gz
puis reprendre la demarche qui a ete bien tres bien detaille voir meme ci-dessus.
Petit probleme a documenter et en passe a la partie 3:(-N: lister un nouveaufichier en integrite)
ATTENTION: flags pour generer un patch et attention au fichier .rej...
&& -p1 pour ignorer le 1er element du chercheur depuis le patch sinon erreur.
On doit LUI DIRE qu'il faut appliquer le patch suivant nn/demos/.. et voila!
sortie de patch < ../patch_number par exemple rien faire sinon rej qui veut certainement dire(pas important) qu'on applique le patch en bouleversant l'etat des executions globaux par un cmakelists .rej qui veut dire skip patch precedent et applique le quoi qu'il en soit(les lignes principaux) vu que la cible n'est pas la meme le fichier genere est de ce type..
Un build present presente a 90% les memes problemes/***********************
Une non specification de la profondeur depuis les debuts des sous patch genere la meme erreur ilattend un y tout long va generer les sources direct avec le symbole .rej pour des raisons de securite soit disant(cmakelists lui aussi touche dans les sous repertoires demos par exemple pour lexo suivant qui fait un melange gracieux de repertoirs non compatibles).
FIN_REMARQUES.
->exo8:
conseils: faire des copies sans build appliquer le patch sur les bons repertoires depuis le demandeur avec -p1 si on est en entree et faire des -x sur les .git eventuellement d'autres fichiers doc(Doxyfile.in) pour que diff -rupN maitre de generationde patch ne pause pas probleme lors de l'applciation(pas trop de donneees a traiter) et ce qui est important: verifier tjrs avec diff -r et l'entier repertoir de github avant un commit avec git diff -r quidonnera pas grand chose.. a append c cancelled pour bien decrypter les messages.
DERNIER CONSEIL: le but d'un diff cest de pouvoir l'appliquer, la elcture specifique de chaque ligne est libre et le patch genere en est important et comment l'appliquer aussi.
>supprimer le build2 build dans une copie de statelib supprimera le contenu de doc et evitera de chercher dans man git quelle option pour ignorer le repertoir doc meme si on l'a: -x (car .git est un folder non pas un fichier comme ~/.bashrc) et donc:
>>cp -r statelib statelib3_test + reprendre la faute pour en generer un meme patch(meme nom+meme commandes)
>>>maintenant, concentrons-nous sur le pathc_print.gz::
il contient un state print en plus pour la librairie courante.
+possiblite de dynamisme en terme de libraries dans le cmakelists principle.
+ajout de print_state__machine(dans le main avant le restart)
+l'implementationTOUT EN BAS CEST CLAIR. (ca list tout ~comme on a affirme avant)
+derniere chose: start=p->to comme mac en parametre et macro linux pour inclure un header.
++de choses bien sur mais en resume:
a)debut de dynamisme.(chargement dynamique peut etre prevue)
b)implementation de la fonction qui imprime la machine a etats en courants(s!!)
c)specifications ajoutees non presentes le dernier + rejoint l'avant dernier.
=>necessite de bien lire les diff -rupN surtout car ca apporte le max. de donnees maniables flexiblement.
A reprendre apres l'application de patch.print_ avant de passer a la suite..
REPRISE RAPIDE:
statelib2 => statelib2_patched en copie cad. statelib<->statelib2(build/build2 sautent): (avec statelib_new2 copie de statelib_new (on supprime tous les build avec diff -rupN -x .git pour la generation du patch et diff -r pour comparer le resultanr=t(original/new avec new ;build3 aussi))) donne statelib2_patched patch avec une copie statelib_new2_patched donne rien.(<=>patch de (diff -rupN precisement) de statelib_new2 et de statelib_new2_patched puis application du patch depuis statelib_new2_patched).//////
DERNIERE REMARQUE SUR LA REPRISE: un travail parallele+un patch at all fait le boulot attendu un diff -r par exemple sur une copie externe et sur le copie modifiee just in time(())²²²²   fait la sortie voulue(aucune chose sauf le .git qu'on peut ignorer avec -x git).
REVENONS A LEXO IMPORTANT:
DISCUTONS SUR LE PIEGE ICI::
ce patch contient une modification du CMakeLists.txt qui pose enormement de problemes, ainsi qu'une implementation d'une fonction avant le restart de print les states de la machine avec centrage sur le state courant. la lecture de diff ne doit pas approfondue. L'application par contre du patch et ses repercussions via la visualisation du diff -r est le primordial et notre priorite ici.
/*/*
reprendre la demarche
<=>less patch.print_ && mv statelib_all_1_sur_2/statelib2 ./ && cp -r statelib2 statelib
=>on a deux folders statelib et statelib2 copies conformes aux regles precises(repliques memes..)
=>cd statelib && patch -p1 < ../patch.print_ => repercussions sur statelib
avant: rm CMakeLists.txt (###) && mv CMakeLists.txt.orig CMakeLists.txt (voir patch.print_ et bien l'inspecter(-)).
PUIS: on revient vers le repertoir parent, on fait::
diff -rupN statelib statelib2 > new_patch && cd statelib && patch -p1 < ../new_patch
=>ca va se repercuter direct car nous qu'on a bien GENERE LE OWN PATCH '$$file$$'````.
=>applications directs du patch.print_ sans erreurs sur statelib en passant par une copie intermediaire<=>ouverture en PLUS vers l'objet des exercices SUIVANTS(l'avant dernier en PARTICULIER).
RQ: .rej nous sauve la vie si il y en pas ; on respecte les conventions c'est statelib2 ou on doit appliquer ceci on le fait puis on fait les modifs. sur les *.txt?orig puis on genere un nouveau patch depuis statelib(old) pour l'appliquer a celui ci et avoir LA VERSION COURANTE QUI MARCHE A PLEIN REGIME.//
RQ2: on pourrait se restreindre a appliquer le patch patch.print_ a statelib2 et avoir une nouvelle version optimisee de statelib2 (~#~#)  a partir du fichier patch tout en gardant statelib intact en faisant les bonnes modifications apres.(-p1 impose implicitement cela mais cest mieux que de se melanger les pinceux avec une application BRUTE(deconseillee meme pour les plus grands developpeurs)) ON REFAIT UN git clone apres avoir cree le folder statelib_2_sur_2 pour avoir la version statelib pour la derniere partie du TD (sans build eventuellement pour le qt-creator(deja fait) et sans les modifs. de patch.print_ car pas demandees avant).
*/*/
**********************************************************************************************
**********************************************************************************************
**********************************************************************************************
3.>GIT: commit/status/avant add puis status/log(origin/master -> origin/HEAD depuis le proprietaire machine depot statelib(allali))/git reset HEAD~1..HEAD/git commit -m -a <=> git add * puis git push
-tout ca on le sait.
LE NOUVEAU:
EXO10/11:
facile;; resume rapide:->
/*/*
 (DOING THE 1/2 job from now).from commiting and being updating each time oberserved.



/*/*
EXO11:(le coeur de l'histoire)





































**********************************************************************************************
**********************************************************************************************
**********************************************************************************************
**********************************************************************************************
**********************************************************************************************
**********************************************************************************************
EXO12: qtcreator avec build-statelib-Desktop-Debug ouvre avec la copie depuis statelib_all_1_sur_2''(()) => changement pris en compte avec save puis modification de la branche locale de ce repertoir inclut diff (pas necessairement git) puis tools(outils) puis depot local(local repository) diff (on l'a fait c'est l'essentiel) affiche tout bien en graphique.[revoir les explications precedentes pour plus de manips. internes consolées en mode NO]./////////////







FIN TD_6.

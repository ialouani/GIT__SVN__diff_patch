GIT/SVN/diff-patch :patch.print(sources) apress.//
1.***********************
But de la biblio: machines a etats::
>chaque fonction prend un void* depuis un lancement initial renvoie un int qui indique un saut vers une autre fonction <=> machine a etats.
..////
->MIT liscence + auteur: allali.(fichier LISCENCE PAS Readme.md qui decrit ce que fait la bibliotheque avec les conventions + la documentation(comment l'utiliser , ainsi de suite..))
systeme de gestion de sources: decentralise git.
NON copyright pour une liscence (+<-### attention ! ;;;)
------------------------
mkdir a l'avant puis git clone (deja fait..(<<)).
systeme de compilation : cmake.(systeme permettant de faire l'out source building (donc .compilation UNIQUEMENT))
systeme de documentation: doxygen doc/Doxyfile.in non lance comme cmake jusqu'a present c'est normal pas comme notr propre ++release()().
----------------------------------------
cmake .. && make && demos/demo_menu+''<<<|>><<||||demo_basic.
make install cree probleme sans indication de ou on doit installer (a l'exterieur peut etre /usr c'est mieux).
=>rm -rf * build && cmake -DCMAKE_INSTALL_PREFIX:PATH=$HOME/usr
=>on relance: cmake avec l'option puis make puis make install.
=>=>repercusions immediates sur ~/Bureau/usr_install_2 (tests+).
=>make donc aussi depuis build puis firefox doc/html/index.html.
tout est bien(autre cote aussi~+).
RQ:
ON PEUT faire cmake avec cette option direct ca va faire le make avant + l'installation de include lib dans $HOME(~)/usr apres make install mais make doc nn.
sudo make install est l'unique choix pour faire un run sans erreur car ca copie les fichiers dans /usr/local/include(.h) && /usr/local/lib(les biblios dynamiques dela libc utilisees instinctivement par GCC.)
------------------------------------------------------------------

2:*********************(diff/patch)
changer la documentation state_start par exemple=>tjrs (90%)voir ateliers_projets fichiers dispos d'origines (initial commit) .h
=>cd depuis cp -r statelib statelib_new puis cd bon folder puis cd src puis cat state.h pour voir.
rq:(install)******************
TARGETS DESTINITATION dans install() le fichier cmake.txt renvoie le repertoir par defaut a choisir eventuellement cest pour cela qu'on ajoute l'option fondamentale a ne pas oublier:
-CMAKE_INSTALL_PREFIX:PATH=$HOME/usr pour une installation dans ~/usr. (ou bien sudo make install comme ca l'ajout avec <> ne posera pas de problemes..)
revenir a l'exo4:
tout a ete fait, les exemples ont ete bien traites pour choisir la tres bonne proche(bonne!!) implementation de game1__2 && searching_number__game => demo/demo3 && demo/demo3_v2 via le CMakeLists dans le folder (**)demos(build :../ terminal.///)::
 +aadd_executable(.. ..)//classique
 ++target_link_libraries(executable$''```` ${STATE_LIBRARIES}).
et depuis statelib_new on fait un cd build3 && cmake -DCMAKE_INSTALL_PREFIX:PATH=$HOME .. && make && make doc 
=>on visualise le :>(sortie) $(firefox ''./doc/html/index.html'') qst1/2
==>on execute les programmes (**)=>TOUT MARCHE.
FIN EXO4: modifications.
_______________________
__________________________________EXO5/6: application/observations diverses(../$($$)) de diff-patch (FRAMEWORK<-->principe des egstionnaires de sources=>$$*($$$<<<<<|./&..////²²²²²²))
EXO5: DIFF
commandes a reprendre(rappels seulement) avec options si necessaire:
diff -r(git diff au debut sur le repository personnel de github)
diff -y(en mode parallele + details sous que faire documentation state.h par exemple
+les repertoirs non pas de recherche recursif si ajout complet contrairement a src=>break
=>documentation sur state.h..) ne sert pas a grand chose.<=>~-++diff -r.
diff
diff -rupN
diff -r -x .git build(exemple) original new
diff -ru -x .git -x ...
jusqu'a diff -rupN -x .git -x build ...
RQ: les options r/ru/rup ne donnent pas grand choses mais permettent de mieux visualiser les trucs=>l'ajout de N est fondamental.(tenant compte des -x ?? pour que l'ensemble #??# ne soit pas lui aussi analyse par rapport a l'ajout des lignes du second image importe cp -R muis mv puis modifiees)
(details: diff -r -x .git -x ('file') original new) VOIR PLUS BAS.
EXO6: patch(de meme => procedure de l'exo precedent(EXO5))
(probleme=>generationde patch anticipee triviale!(*))
diff -rupN -x .git ignore en comparaison resursive la presence ou pas des fichiers .git.(la comparaison par exemple pour -x build va pas comparer statelib/build et statelib_new/build cest pour cela il est recommande de faire les build a l'EXTERIEUR mais le readme initial imposait une construction conforme au CMakeLists se retrouvant dans demos par exemple pour link_directories donc on se confie a la documentation car meme si on modifie tout on peut pas COMMITER)
=>on genere au lieu de patch_number le patch2_real.
**********************-------------------------------------------------------------
EXO7:
Resume: pour faire un patch on utilise uniquement les options diff -rupN original new > patch_`${second_patch__name}`.
Le patch etant pres: patch_real2.
=>comparaison tenu en compte de l'ajout des commentaires dans les fichiers sources headers(contrats) tout au debut + l'ajout d'autres fichiers tests (2) + l'updating du Makefile.
fin_resume__etapes PRECEDENTES.
A CONCLURE POUR LA __suite__::: diff -rupN -x .git -x build_?? ()..()'-x-><-number' original new > rslt_patch.print_ ou rslt_patch tout simple.
->REVENONS A LEXO7:
MAIS<<: parfois, il faut bien examiner les cas car l'application ulterieure du patch CE QUI EST L'objet de cet exo pose des problemes de post-configuration().
=>DETAILS.
Rq:
LE prof a precise qu'il a pu transporter la machine a etats sans toucher aux fonctionnalitées cad. les fonctions proposees ce qui est vraiment l'OBJECTIF d'une machine a etats.
=>=>=>REPRENONS PLUS EN **PROFONDEUR** l'exo7:
creation d'une copie de statelib en statelib2
PUIS: diff -rupN (u:context&p:functions&r:recursivite en recherche & comparaison des ajouts && N END for generating the main line codes for the patch_number) statelib2 statelib_new2 (copie de ce dernier aussi apres AVOIR SUPPRIMER TOUT LES REPERTOIRS BUILD) avec les flags::²
                       -x .git -x build(comme rm -r''f'') 
                          >patch_number.
PUIS: cd statelib2_patched copie de statelib2 sans le build commeon a dit avant puis:
patch < ../patch_games avec l'option !!!!!!!!!!!!!!-p1-----------------(voir commit comment's).
!!!!!!!!!!!!!!!!!!!!!!!!!!
application et repertoriation des modifications puis diff -r => difference au niveau des .git seulement cat -x .git les a sautées.(pas besoin car pas acces(bloqué pas de repository contenant celui-ci) pour y acceder donc le .git on s'en fiche)
&& les cmakelists.txt.??? sont totalement exclus car: tout simplement::
-p1 avec ++++++++++++++++++++++++build sans ne fait rien meme les executables de 'sortie' de doc sont sautées(voir td precedent).
FIN___EXO7.
**********
*******************
*******************************************
EXO8:(a present)
=>debut_exo__8;;;

